<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mon Cœur Interactif - Saint-Valentin</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@700&family=Montserrat:wght@300&display=swap" rel="stylesheet">

    <style>
        body { margin: 0; overflow: hidden; background: #050505; font-family: 'Montserrat', sans-serif; color: white; }
        canvas { display: block; position: absolute; top: 0; left: 0; z-index: 1; }

        /* Interface utilisateur */
        #ui {
            position: absolute; top: 20px; left: 20px; z-index: 100;
            background: rgba(0, 0, 0, 0.6); backdrop-filter: blur(15px);
            padding: 20px; border-radius: 15px; border: 1px solid rgba(255, 77, 109, 0.3);
            width: 250px;
        }

        h1 { font-family: 'Dancing Script', cursive; margin: 0 0 15px 0; color: #ff4d6d; font-size: 1.8em; }
        .control-group { margin-bottom: 12px; }
        label { display: block; font-size: 0.75em; margin-bottom: 5px; color: #ffb1bf; text-transform: uppercase; letter-spacing: 1px; }
        
        select, input {
            background: rgba(255,255,255,0.1); border: 1px solid rgba(255, 77, 109, 0.5); color: white;
            padding: 8px; border-radius: 5px; width: 100%; outline: none;
        }

        /* Poème */
        #poem-zone {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            text-align: center; z-index: 5; width: 90%; pointer-events: none;
        }

        .poem-text {
            font-family: 'Dancing Script', cursive; font-size: 1.5rem;
            line-height: 1.6; color: #ffd700; opacity: 0.9;
            text-shadow: 0 0 15px rgba(0,0,0,0.8); margin: 0;
        }

        #love-text {
            position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%);
            font-family: 'Dancing Script', cursive; font-size: 4.5rem;
            text-shadow: 0 0 30px rgba(255, 77, 109, 0.9);
            pointer-events: none; z-index: 4; text-align: center; width: 100%;
        }

        #fs-btn {
            position: absolute; bottom: 20px; right: 20px;
            background: #ff4d6d; border: none; color: white; padding: 12px 24px;
            border-radius: 30px; cursor: pointer; font-weight: bold; z-index: 110;
        }

        #loading {
            position: fixed; inset: 0; background: #050505; display: flex;
            flex-direction: column; align-items: center; justify-content: center; z-index: 1000;
        }
        .heart-loader { color: #ff4d6d; font-size: 3rem; animation: pulse 1s infinite; }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.2); } 100% { transform: scale(1); } }
        
        /* Fenêtre de contrôle caméra (invisible mais active) */
        video { position: fixed; bottom: 10px; left: 10px; width: 120px; border-radius: 10px; opacity: 0.3; z-index: 50; transform: scaleX(-1); border: 1px solid #ff4d6d; }
    </style>
</head>
<body>

    <div id="loading">
        <div class="heart-loader">❤</div>
        <p>Connexion à la magie...</p>
    </div>

    <video id="webcam" autoplay playsinline></video>

    <div id="ui">
        <h1>Pour Mon Amour</h1>
        <div class="control-group">
            <label>Forme</label>
            <select id="shape-select">
                <option value="heart">Cœur Éternel</option>
                <option value="flower">Fleur de Printemps</option>
                <option value="galaxy">Galaxie Infinie</option>
                <option value="rings">Anneaux d'Or</option>
            </select>
        </div>
        <div class="control-group">
            <label>Couleur</label>
            <input type="color" id="color-picker" value="#ff4d6d">
        </div>
        <div class="control-group">
            <label>Message</label>
            <input type="text" id="message-input" value="Je t'aime">
        </div>
    </div>

    <h2 id="love-text">Je t'aime</h2>

    <div id="poem-zone">
        <p class="poem-text">
            "Comme ces étoiles qui dansent sous tes doigts,<br>
            Mon cœur palpite et ne bat que pour toi."
        </p>
    </div>

    <button id="fs-btn">Plein Écran</button>

    <script>
        let scene, camera, renderer, particles, geometry, material;
        let particleCount = 16000;
        let positions = new Float32Array(particleCount * 3);
        let targetPositions = new Float32Array(particleCount * 3);
        let lerpScale = 1.0;
        let targetScale = 1.0;

        const video = document.getElementById('webcam');
        const colorPicker = document.getElementById('color-picker');
        const shapeSelect = document.getElementById('shape-select');
        const messageInput = document.getElementById('message-input');
        const loveText = document.getElementById('love-text');

        function initThree() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 6;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            geometry = new THREE.BufferGeometry();
            material = new THREE.PointsMaterial({
                size: 0.035,
                color: new THREE.Color(0xff4d6d),
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            createShape('heart');
            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            window.addEventListener('resize', onWindowResize);
            animate();
        }

        function createShape(type) {
            for (let i = 0; i < particleCount; i++) {
                let x, y, z;
                if (type === 'heart') {
                    const t = Math.random() * Math.PI * 2;
                    x = 16 * Math.pow(Math.sin(t), 3) * 0.18;
                    y = (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) * 0.18;
                    z = (Math.random() - 0.5) * 1;
                } else if (type === 'flower') {
                    const a = Math.random() * Math.PI * 2;
                    const r = (2 * Math.sin(5 * a) + 3) * 0.6;
                    x = r * Math.cos(a); y = r * Math.sin(a); z = (Math.random() - 0.5);
                } else if (type === 'galaxy') {
                    const a = i * 0.005; const r = a * 0.8;
                    x = r * Math.cos(a) + (Math.random() - 0.5);
                    y = r * Math.sin(a) + (Math.random() - 0.5);
                    z = (Math.random() - 0.5) * 4;
                } else {
                    const r = 5; const t = Math.random() * Math.PI * 2;
                    x = r * Math.cos(t); y = r * Math.sin(t) * 0.2; z = r * Math.sin(t);
                }
                targetPositions[i * 3] = x;
                targetPositions[i * 3 + 1] = y;
                targetPositions[i * 3 + 2] = z;
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        }

        // --- DÉTECTION ROBUSTE (Firefox & Chrome) ---
        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });

        hands.setOptions({ 
            maxNumHands: 1, 
            modelComplexity: 1, 
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5 
        });

        hands.onResults((results) => {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const pts = results.multiHandLandmarks[0];
                // Distance euclidienne entre le bout du majeur (12) et la base de la paume (0)
                const dx = pts[12].x - pts[0].x;
                const dy = pts[12].y - pts[0].y;
                const distance = Math.sqrt(dx*dx + dy*dy);
                
                // Si la distance est courte = main fermée
                targetScale = distance < 0.28 ? 0.35 : 2.3;
            } else {
                targetScale = 1.0;
            }
        });

        const cameraMp = new Camera(video, {
            onFrame: async () => { await hands.send({ image: video }); },
            width: 640, height: 480
        });

        cameraMp.start()
            .then(() => document.getElementById('loading').style.display = 'none')
            .catch(() => alert("Active la caméra pour l'effet magique !"));

        function animate() {
            requestAnimationFrame(animate);
            
            lerpScale += (targetScale - lerpScale) * 0.1;
            const breathe = (Math.sin(Date.now() * 0.002) * 0.15) + lerpScale;
            
            const posAttr = geometry.attributes.position;
            for (let i = 0; i < particleCount; i++) {
                positions[i*3] += (targetPositions[i*3] * breathe - positions[i*3]) * 0.15;
                positions[i*3+1] += (targetPositions[i*3+1] * breathe - positions[i*3+1]) * 0.15;
                positions[i*3+2] += (targetPositions[i*3+2] * breathe - positions[i*3+2]) * 0.15;
            }
            posAttr.needsUpdate = true;
            particles.rotation.y += 0.003;
            
            renderer.render(scene, camera);
        }

        shapeSelect.addEventListener('change', (e) => createShape(e.target.value));
        colorPicker.addEventListener('input', (e) => material.color.set(e.target.value));
        messageInput.addEventListener('input', (e) => loveText.innerText = e.target.value);
        document.getElementById('fs-btn').addEventListener('click', () => {
            if (!document.fullscreenElement) document.documentElement.requestFullscreen();
            else document.exitFullscreen();
        });

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        initThree();
    </script>
</body>
</html>
